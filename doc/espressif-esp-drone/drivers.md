<!-- Переведено с https://docs.espressif.com/projects/espressif-esp-drone/en/latest/ -->
<!-- Оригинал: английский | Перевод: русский | Инструмент: Google Translate API -->

# Драйверы

[中文]

В этом разделе описаны драйверы I2C и драйверы SPI, используемые в ESP-Drone.

## Драйверы I2C

Драйверы I2C включают драйвер датчика MPU6050 и драйвер датчика VL53LXX. В следующей части описаны два датчика, их основные функции, ключевые регистры, примечания по программированию и т. д.

### Датчик MPU6050

#### Обзор

MPU6050 — это 6-осевое устройство отслеживания движения, сочетающее в себе 3-осевой гироскоп, 3-осевой акселерометр и цифровой процессор движения (DMP).

#### Как это работает

- Гироскоп: вибрация возникает из-за эффекта Кориолиса, когда гироскоп вращается вокруг любой оси измерения. Такая вибрация может быть обнаружена емкостным датчиком. Этот емкостный датчик может усиливать, демодулировать и фильтровать такой вибрационный сигнал, а затем генерировать напряжение, пропорциональное угловой скорости.
- Акселерометр: когда смещение ускоряется вдоль определенной оси относительно соответствующей массы обнаружения, емкостный датчик обнаруживает изменение емкости.

#### Диапазон измерения

- Полномасштабный диапазон гироскопа: ±250°/сек, ±500°/сек, ±1000°/сек, ±2000°/сек.
- Полный диапазон акселерометра: ±2 г, ±4 г, ±8 г, ±16 г

#### Интерфейс AUX I2C

- MPU6050 имеет вспомогательную шину I2C для связи с внешним 3-осевым магнитометром или другими датчиками.
- Интерфейс AUX I2C поддерживает два режима работы: основной режим I2C или сквозной режим.

#### МПУ6050 ФИФО

MPU6050 содержит регистр FIFO размером 1024 байта, доступный через последовательный интерфейс. Регистр конфигурации FIFO определяет, какие данные записываются в FIFO. Возможные варианты включают данные гироскопа, данные акселерометра, показания температуры, показания вспомогательных датчиков и вход FSYNC.

#### Цифровой фильтр нижних частот (DLPF)

MPU6050 имеет собственный фильтр нижних частот. Пользователи могут настроить регистр 26 CONFIG — настроить DLPF для управления полосой пропускания, чтобы снизить высокочастотные помехи, но эта конфигурация может снизить скорость входного сигнала датчика. Включите DLPF: акселерометр выдает сигнал частотой 1 кГц; отключить DLPF: акселерометр выдает сигнал частотой 8 кГц.

#### Вывод выборки кадровой синхронизации (FSYNC)

Поле EXT_SYNC_SET в регистре 26 используется для настройки выборки выводов внешней кадровой синхронизации (FSYNC).

#### Цифровая обработка движения (DMP)

- MPU6050 имеет собственный DMP, который можно использовать для расчета кватернионов, чтобы разгрузить вычислительную мощность основного процессора.
- DMP может вызвать прерывание через вывод.

![MPU6050 DMP](_images/mpu6050_dmp_en.png)

МПУ6050 ДМП

#### MPU6050 Ориентация

MPU6050 определяет свою ориентацию следующим образом.

![mpu6050_xyz](_images/mpu6050_xyz.png)

MPU6050 Ось X, Y, Z

#### Инициализация MPU6050

- Восстановить настройки реестра по умолчанию:

- Установите бит 7 PWR_MGMT_1 в 1,
- а затем в 0 после восстановления значений регистра по умолчанию.
- Бит 6 автоматически устанавливается в 1, что переводит MPU6050 в спящий режим;

- Установите бит 6 PWR_MGMT_1 на 0, чтобы активировать датчик;
- Установите источник синхронизации;
- Установите диапазон гироскопа и акселерометра;
- Установите частоту дискретизации;
- Установите цифровой фильтр нижних частот (дополнительно).

#### Ключевые регистры MPU6050

##### Типичные значения регистров

| Зарегистрироваться | Типичное значение | Особенность |
| --- | --- | --- |
| PWR_MGMT_1 | 0x00 | Нормальное Включение |
| SMPLRT_DIV | 0x07 | Частота дискретизации гироскопа: 125 Гц |
| КОНФИГ | 0x06 | Частота фильтра DLPF: 5 Гц |
| ГИРО_КОНФИГ | 0x18 | Гироскоп не проводит самотестирование, его полномасштабная выходная мощность составляет ±2000 °/с. |
| АКЦЕЛ_КОНФИГ | 0x01 | Акселерометр не проводит самотестирование, его полномасштабный выходной сигнал составляет ±2 g. |

##### Регистр 117 WHO_AM_I — Адрес устройства

Биты [6:1] хранят адрес устройства и по умолчанию равны 0x68. Значение вывода AD0 не отражается в этом регистре.

![WHO_AM_I](_images/REG_75.png)

##### Регистр 107 PWR_MGMT_1 — Управление питанием 1

![PWR_MGMT_1](_images/REG_6B.png)

- DEVICE_RESET: если этот бит установлен, регистр будет использовать значение по умолчанию.
- SLEEP: если этот бит установлен, MPU6050 будет переведен в спящий режим.
- CYCLE: если этот бит (CYCLE) установлен в 1, а режим SLEEP отключен, MPU6050 перейдет в циклический режим. В циклическом режиме MPU6050 переключается между спящим режимом и пробуждением, чтобы получить одну выборку данных от активных датчиков со скоростью, определяемой LP_WAKE_CTRL (регистр 108).

##### Регистр 26 CONFIG — настройка DLPF

![CONFIG](_images/REG_1A.png)

DLPF настраивается с помощью DLPF_CFG. Акселерометр и гироскоп фильтруются в соответствии со значением DLPF_CFG, как показано в таблице ниже.

![DLPF](_images/DLPF_CFG.png)

##### Регистр 27 — GYRO_CONFIG — настройка полномасштабного диапазона гироскопа.

![GYRO_CONFIG](_images/REG_1B.png)

- XG_ST: если этот бит установлен, гироскоп оси X выполняет самотестирование.
- FS_SEL: выберите полную шкалу гироскопа, подробности см. в таблице ниже.

![FS_SEL](_images/FS_SEL.png)

##### Регистр 28 ACCEL_CONFIG — настройка полномасштабного диапазона акселерометра.

Пользователи могут настроить полный диапазон акселерометра в соответствии с таблицей ниже.

![ACCEL_CONFIG](_images/REG_1C.png)

![AFS_SEL](_images/AFS_SEL.png)

##### Регистр 25 SMPRT_DIV — делитель частоты дискретизации

Регистр определяет делитель выходной частоты гироскопа, используемый для генерации частоты дискретизации для MPU6050. Выходные данные регистра датчика, выходные данные FIFO и выборка DMP основаны на частоте выборки. Частота дискретизации генерируется путем деления выходной частоты гироскопа на (1 + SMPLRT_DIV).

![SMPRT_DIV](_images/REG_19.png)

Частота выборки = Частота вывода гироскопа / (1 + SMPLRT_DIV)

Выходная частота гироскопа = 8 кГц, когда DLPF отключен (DLPF_CFG = 0 0r 7), и 1 кГц, когда DLPF включен (см. регистр 26). Примечание: если для SMPLRT_DIV установлено значение 7, когда DLPF отключен, микросхема может генерировать сигнал прерывания частотой 1 кГц.

![SMPLRT_DIV=7](_images/mpu6050_int_plot.png)

##### Регистры 59 ~ 64 — измерения акселерометра

![REG_3B_40](_images/REG_3B_40.png)

- Сохраняйте данные с прямым порядком байтов: старшие биты данных хранятся по младшему адресу, а младшие биты по старшему адресу.
- Сохранение данных в дополнении: значение измерения представляет собой целое число со знаком, поэтому его можно сохранить в дополнении.

##### Регистры 65 ~ 66 — измерение температуры

![REG_41_42](_images/REG_41_42.png)

##### Регистры 67 ~ 72 — измерения гироскопа

![REG_43_48](_images/REG_43_48.png)

### Датчик VL53LXX

Обзор

VL53L1X — это датчик измерения времени полета и обнаружения жестов, предоставленный ST.

Как это работает

Чип VL53L0X/VL53L1X внутренне интегрирован с лазерным передатчиком и инфракрасным приемником SPAD. Обнаруживая разницу во времени между отправкой и получением фотонов, чип вычисляет расстояние полета фотонов, а максимальное расстояние измерения может достигать двух метров, что подходит для измерений на коротких и средних дистанциях.

![VL53LXX](_images/vl53l1x_package.png)

ВЛ53ЛХХ

Область измерения – область интереса (ROI)

VL53L0X/VL53L1X измеряет кратчайшее расстояние в области измерения, масштаб которой можно увеличивать или уменьшать в зависимости от фактического сценария. Но большой диапазон обнаружения может вызвать колебания в измерениях.

Дополнительную информацию о настройке области измерения см. в разделах 2.4 «Описание диапазона» и «2.8 Оптический центр сенсорной матрицы» в Техническом описании VL53LXX.

![ROI](_images/vl53lxx_roi.png)

ROI

Измерить расстояние

- Датчик VL53L0X имеет слепую зону 3–4 см, эффективный диапазон измерения 3–200 см и точность ±3%.
- VL53L1X — это модернизированная версия VL53L0X с дальностью обнаружения до 400 см.

| Точный режим | Время измерения (мс) | Диапазон измерения (м) | Приложения |
| --- | --- | --- | --- |
| По умолчанию | 30 | 1.2 | Стандартный |
| Высокая точность | 200 | 1,2 <+-3% | Точное измерение расстояния |
| Дальняя дистанция | 33 | 2 | Большое расстояние, работает только в темноте. |
| Высокоскоростной | 20 | 1,2 +-5% | Приоритет скорости с низкой точностью |

- Расстояние/производительность измерения VL53LXX зависят от окружающей среды. Расстояние обнаружения больше в темных условиях. Но при ярком освещении на открытом воздухе лазерный датчик может подвергаться сильным помехам, что приводит к снижению точности измерений. По этой причине высоту следует устанавливать в зависимости от давления наружного воздуха.

![VL53L1X mode](_images/vl53l1x_max_distance.png)

Частота измерения

- Частота измерения VL53L0X составляет до 50 Гц, погрешность измерения ±5%.
- VL53L1X I2C имеет максимальную тактовую частоту 400 кГц, а подтягивающий резистор необходимо выбирать исходя из значений напряжения и емкости шины. Для получения дополнительной информации см. техническое описание VL53LXX.

![vl53l1x](_images/vl53l1x_typical_circuit.png)

ВЛ53Л1Х

- XSHUT, входной контакт для выбора режима (спящий режим), всегда должен быть включен во избежание тока утечки. Нужен подтягивающий резистор.
- GPIO1, выходной контакт прерывания для измерения прерываний, готовых к передаче данных.

Режим работы

Установив уровень на выводе XSHUT, датчик можно переключить в режим ожидания аппаратного обеспечения или режим ожидания программного обеспечения для условной загрузки и снижения энергопотребления в режиме ожидания. Если хост отказывается от управления режимами датчиков, вывод XSHUT можно настроить на подтягивание по умолчанию.

- Аппаратный режим ожидания: XSHUT опускается и питание датчика отключается.
- Режим ожидания ПО: XSHUT поднимается, затем датчик переходит в режимы загрузки и ожидания ПО.

![HW Standby](_images/vl53lxx_power_up_sequence.png)

Аппаратное обеспечение в режиме ожидания

![SW Standby](_images/vl53lxx_boot_sequence.png)

ПО в режиме ожидания

#### VL53LXX Инициализация

- Дождитесь завершения инициализации оборудования.
- Инициализация данных
- Статическая инициализация, загрузка данных
- Установить режим дальности
- Установите максимальное время ожидания для одного измерения
- Установите частоту измерения (интервал)
- Установите область измерения ROI (необязательно)
- Начать измерение

```
/*init  vl53l1 module*/
void vl53l1_init()
{

    Roi0.TopLeftX = 0;    //Measurement target area (optional). Min: 4*4, Max: 16*16.
    Roi0.TopLeftY = 15;
    Roi0.BotRightX = 7;
    Roi0.BotRightY = 0;
    Roi1.TopLeftX = 8;
    Roi1.TopLeftY = 15;
    Roi1.BotRightX = 15;
    Roi1.BotRightY = 0;

    int status = VL53L1_WaitDeviceBooted(Dev); // Wait for the initialization of the hardware to complete
    status = VL53L1_DataInit(Dev); // Data initialization, is executed immediately after wake up;
    status = VL53L1_StaticInit(Dev); // Static initialization, loading parameters.
    status = VL53L1_SetDistanceMode(Dev, VL53L1_DISTANCEMODE_LONG);// Set ranging mode;
    status = VL53L1_SetMeasurementTimingBudgetMicroSeconds(Dev, 50000); // Set the maximum wait time based on the measurement mode.
    status = VL53L1_SetInterMeasurementPeriodMilliSeconds(Dev, 100); // Set the measurement interval.

    status = VL53L1_SetUserROI(Dev, &Roi0); //Set measurement area ROI
    status = VL53L1_StartMeasurement(Dev); //Start the measurement
    if(status) {
        printf("VL53L1_StartMeasurement failed \n");
        while(1);
    }

}

```

Примечание. За исключением шага VL53L1_SetUserROI, остальные шаги инициализации пропустить нельзя.

#### VL53LXX Шаг регулирования

Ранжирование может осуществляться в двух режимах: режиме опроса и режиме прерывания.

Рабочий процесс режима опроса

![vl53lxx_meaturement_sequence](_images/vl53lxx_meaturement_sequence.png)

Последовательность измерений VL53LXX

Примечание

- Каждый раз, когда измерение и считывание значений выполняются, очищайте флаг прерывания с помощью VL53L1_ClearInterruptAndStartMeasurement, а затем снова запускайте измерение.
- В режиме опроса предусмотрено два метода, как показано на рисунке выше: режим опроса драйверов и режим опроса хоста. В качестве примера возьмем режим опроса драйверов.

```
/* Autonomous ranging loop*/
static void
AutonomousLowPowerRangingTest(void)
{
    printf("Autonomous Ranging Test\n");

    static VL53L1_RangingMeasurementData_t RangingData;
    VL53L1_UserRoi_t Roi1;
    int roi = 0;
    float left = 0, right = 0;
    if (0/*isInterrupt*/) {
    } else {
        do // polling mode
            {
                int status = VL53L1_WaitMeasurementDataReady(Dev); // Waiting for the measurement result
                if(!status) {
                    status = VL53L1_GetRangingMeasurementData(Dev, &RangingData); // Get a single measurement data
                    if(status==0) {
                        if (roi & 1) {
                            left = RangingData.RangeMilliMeter;
                            printf("L %3.1f R %3.1f\n", right/10.0, left/10.0);
                        } else
                            right = RangingData.RangeMilliMeter;
                    }
                    if (++roi & 1) {
                        status = VL53L1_SetUserROI(Dev, &Roi1);
                    } else {
                        status = VL53L1_SetUserROI(Dev, &Roi0);
                    }
                    status = VL53L1_ClearInterruptAndStartMeasurement(Dev); // Release the interrupt
                }
            }
        while (1);
    }
    //  return status;
}

```

Рабочий процесс в режиме прерывания

Прерывание контролируется выводом GPIO1. Когда данные готовы, выключение GPIO1 может сообщить хосту о необходимости прочитать данные.

![vl53lxx autonomous sequence](_images/vl53lxx_sequence.png)

VL53LXX Автономная последовательность

#### Калибровка датчика VL53LXX

Если над приемником датчика установлена ​​маска или датчик установлен за прозрачной крышкой, датчик необходимо откалибровать из-за изменения скорости передачи. Вы можете написать программу калибровки и вызывать API на основе процесса калибровки или измерить значение калибровки напрямую с помощью официального графического интерфейса ПК.

Используйте официальные API для написания программы калибровки

Процесс калибровки показан ниже. Порядок вызовов должен быть точно таким же.

![vl53lxx_calibration_sequence](_images/vl53lxx_calibration_sequence.png)

Последовательность калибровки VL53LXX

```
/* VL53L1 Module Calibration*/
static VL53L1_CalibrationData_t vl53l1_calibration(VL53L1_Dev_t *dev)
{
    int status;
    int32_t targetDistanceMilliMeter = 703;
    VL53L1_CalibrationData_t calibrationData;
    status = VL53L1_WaitDeviceBooted(dev);
    status = VL53L1_DataInit(dev);                                       // Device initialization
    status = VL53L1_StaticInit(dev);                                     // Load device settings for a given use case.
    status = VL53L1_SetPresetMode(dev,VL53L1_PRESETMODE_AUTONOMOUS);
    status = VL53L1_PerformRefSpadManagement(dev);
    status = VL53L1_PerformOffsetCalibration(dev,targetDistanceMilliMeter);
    status = VL53L1_PerformSingleTargetXTalkCalibration(dev,targetDistanceMilliMeter);
    status = VL53L1_GetCalibrationData(dev,&calibrationData);

    if (status)
    {
        ESP_LOGE(TAG, "vl53l1_calibration failed \n");
        calibrationData.struct_version = 0;
        return calibrationData;

    }else
    {
        ESP_LOGI(TAG, "vl53l1_calibration done ! version = %u \n",calibrationData.struct_version);
        return calibrationData;
    }

}

```

Используйте официальный графический интерфейс ПК для калибровки датчика

Компания STM предоставила графический интерфейс ПК для настройки и калибровки датчика.

- Подключите датчик к плате разработки nucleo STM32F401RE, предоставленной STM.
- Используйте программное обеспечение для проведения калибровки и получения эталонного значения.
- Введите это значение во время инициализации.

![STSW-IMG008](_images/vl53lxx_calibrate_gui.png)

Калибровка графического интерфейса ПК

Для получения дополнительной информации см. STSW-IMG008: Графический интерфейс пользователя Windows (GUI) для пакетов VL53L1X Nucleo. Работает с P-NUCLEO-53L1A1.

#### Пример VL53L1X

Пример описания

- Реализация: VL53L1X обнаруживает изменение высоты (длится 1 секунду) и включается красный свет. Высота возвращается к нормальному значению (длится 1 секунду), и загорается зеленый свет.
- Параметры: установите номер I2C, номер порта, номер порта светодиода с помощью команды make Menuconfig.
- Пример анализа можно найти в примечаниях к коду и руководстве пользователя.

Примечания

- Этот пример применим только к VL53L1X, а не к его более старой версии оборудования VL53L0X.
- Согласно документу STM, расстояние измерения составляет 400 см в темноте. В помещении расстояние измерения может составлять от 10 до 260 см.
- Некоторые параметры функции инициализации vl53l1\_init (VL53L1\_Dev\_t \*) необходимо определять в соответствии с фактической средой использования, и есть возможности для оптимизации.
- Убедитесь, что датчик установлен прямо над местом обнаружения.
- Высота основания автоматически калибруется при включении модуля. Если высота основания изменится, параметры необходимо заново сбросить.

Пример репозитория

Нажмите esp32-vl53l1x-test, чтобы проверить пример, или загрузите пример с помощью инструмента git:

```
git clone https://github.com/qljz1993/esp32-vl53l1x-test.git

```

## SPI-драйвер

### Датчик PMW3901

#### Обзор

PMW3901 — это новейший высокоточный маломощный оптический навигационный модуль PixArt, который обеспечивает
Информация о движении XY в широком диапазоне от 8 см до бесконечности. PWM3901 работает с рабочим током менее 9 мА, рабочим напряжением VDD (от 1,8 до 2,1 В), VDDIO (от 1,8 до 3,6 В), а для связи использует 4-проводной интерфейс SPI.

Основные параметры

| Параметр | Ценить |
| --- | --- |
| Напряжение питания (В) | ВДД: 1,8 ~ 2,1 В; ВДДИО: 1,8 ~ 3,6 В |
| Рабочий диапазон (мм) | 80 ~ +∞ |
| Интерфейс | 4-линейный SPI @ 2 МГц |
| Упаковка | 28-контактный корпус COB, размер: 6 x 6 x 2,28 мм. |

Расположение корпуса и контактов

![pmw3901_package](_images/pmw3901_package.png)

Пакет PMW3901

![pmw3901_pinmap](_images/pmw3901_pinmap.png)

Карта контактов PMW3901

Датчик работает при низком рабочем напряжении, и для связи с ESP32 при напряжении 3,3 В требуется напряжение, отличное от VDD и VDDIO.

#### Состояния питания и последовательность

Последовательность включения питания

Хотя PMW3901MB выполняет внутренний самосброс при включении питания, все же рекомендуется записывать регистр Power_Up_Reset каждый раз при подаче питания. Соответствующая последовательность выглядит следующим образом:

- Сначала подайте питание на VDDIO, а затем на VDD, с задержкой не более 100 мс между каждым питанием. Убедитесь, что все поставки стабильны.
- Подождите не менее 40 мс.
- Установите высокий уровень NCS, а затем низкий уровень, чтобы сбросить порт SPI.
- Запишите 0x5A в регистр Power_Up_Reset (или, альтернативно, переключите вывод NRESET).
- Подождите не менее 1 мс.
- Чтение из регистров 0x02, 0x03, 0x04, 0x05 и 0x06 один раз, независимо от состояния вывода перемещения.
- Обратитесь к разделу 8.2 «Регистры оптимизации производительности» таблицы данных PWM3901MB, чтобы настроить необходимые регистры для достижения оптимальной производительности микросхемы.

Последовательность выключения питания

PMW3901MB можно перевести в режим выключения путем записи в регистр выключения. Доступ к порту SPI не должен осуществляться, когда активирован режим выключения, за исключением команды включения питания (запись 0x5A в регистр 0x3A). Доступ к другим микросхемам на той же шине SPI возможен, пока вывод NCS чипа не установлен.

Чтобы отменить режим выключения:

- Установите высокий уровень NCS, а затем низкий уровень, чтобы сбросить порт SPI.
- Запишите 0x5A в регистр Power_Up_Reset (или, альтернативно, переключите вывод NRESET).
- Подождите не менее 1 мс.
- Чтение из регистров 0x02, 0x03, 0x04, 0x05 и 0x06 один раз, независимо от состояния вывода перемещения.
- Обратитесь к разделу 8.2 «Регистры оптимизации производительности» таблицы данных PWM3901MB, чтобы настроить необходимые регистры для оптимальной производительности микросхемы.

Дополнительную информацию см. в разделе «Подключенная бытовая техника и Интернет вещей».

#### Интерпретация кода

Ключевые структуры

```
typedef struct opFlow_s
{
    float pixSum[2]; /*accumulated pixels*/
    float pixComp[2]; /*pixel compensation*/
    float pixValid[2]; /*valid pixels*/
    float pixValidLast[2]; /*last valid pixel*/
    float deltaPos[2]; /*displacement between 2 frames, unit: cm*/
    float deltaVel[2]; /*velocity, unit: cm/s*/
    float posSum[2]; /*accumulated displacement, unit: cm*/
    float velLpf[2]; /*low-pass velocity, unit cm/s*/
    bool isOpFlowOk; /*optical flow*/
    bool isDataValid; /* valid data */
} opFlow_t;

```

- Накопленные пиксели: накопленные пиксели после взлета дрона.
- Пиксельная компенсация: компенсация ошибки пикселей, вызванной наклоном дрона.
- Действительные пиксели: действительные пиксели, которые были компенсированы.
- Смещение между двумя кадрами: фактическое смещение, пересчитанное из пикселей, единица измерения: см.
- Скорость: мгновенная скорость, полученная путем дифференцирования по изменениям смещения, единица измерения: см/с.
- Суммарное перемещение: фактическое перемещение, единица измерения: см.
- Скорость нижних частот: работа нижних частот на скорости повышает гладкость данных.
- Состояние оптического потока: проверьте, правильно ли работает этот датчик оптического потока.
- Действительные данные: данные действительны на определенной высоте.

```
typedef struct motionBurst_s {
  union {
    uint8_t motion;
    struct {
      uint8_t frameFrom0    : 1;
      uint8_t runMode       : 2;
      uint8_t reserved1     : 1;
      uint8_t rawFrom0      : 1;
      uint8_t reserved2     : 2;
      uint8_t motionOccured : 1;
    };
  };

  uint8_t observation;
  int16_t deltaX;
  int16_t deltaY;

  uint8_t squal;

  uint8_t rawDataSum;
  uint8_t maxRawData;
  uint8_t minRawData;

  uint16_t shutter;
} __attribute__((packed)) motionBurst_t;

```

- движение: информация о движении может быть получена в соответствии с битами обнаружения кадра (frameFrom0), режима работы (runMode) и обнаружения движения (motionOccured).
- наблюдение: проверить, есть ли у IC проблемы с EFT/B или ESD. Когда датчик работает правильно, значение должно быть 0xBF.
- deltaX и deltaY: датчик обнаружил движение изображения в направлениях X и Y.
- squal: качество информации о движении, т. е. достоверность информации о движении;
- rawDataSum: сумма необработанных данных, может использоваться для усреднения данных кадра.
- maxRawData и minRawData: максимум и минимум необработанных данных;
- затвор: автоматически регулируемое значение в реальном времени, чтобы гарантировать, что средние данные о движении остаются в пределах нормального рабочего диапазона. Shutter можно использовать вместе с Squal, чтобы проверить, доступна ли информация о движении.

#### Примечания по программированию

- Если данные датчика равны 0 и длятся 1 секунду, это указывает на возникновение ошибки. В этом случае задачи оптического потока следует приостановить.
- Линза датчика должна быть установлена ​​лицевой стороной вниз. Из-за относительного движения данные о смещении, собираемые датчиком, противоположны фактическому направлению движения дрона.
- Включайте режим удержания положения только тогда, когда тест режима удержания высоты стабилен. Точная информация о высоте используется для определения соотношения между пикселями изображения и фактическим расстоянием.
- Ручной тест компенсации наклона может оставить выходной сигнал датчика практически неизменным, даже если дрон наклоняется в определенном направлении.
- С помощью компенсации наклона и накопления пикселей движения можно получить фактические накопленные пиксели. После нескольких вычислений вы можете получить: Изменение пикселей между двумя кадрами = фактические накопленные пиксели – последние фактические пиксели; Изменение смещения между двумя кадрами = Изменение пикселей между двумя кадрами x коэффициент. Обратите внимание, что при высоте менее 5 см оптический поток перестанет работать, поэтому коэффициент следует установить равным 0; Проинтегрируйте вышеуказанные изменения смещения, чтобы получить смещение от четырех осей до точки взлета. Дифференцируйте вышеуказанные изменения смещения, чтобы получить мгновенную скорость. Выполните операцию нижних частот по скорости, чтобы повысить плавность данных. Ограничьте амплитуду скорости для повышения безопасности данных.
- Информация о положении и скорости четырех осей получается через оптический поток, а затем: Вышеупомянутая информация о местоположении и скорости вместе с акселерометром (state_estimator.c) может использоваться для оценки положения и скорости; Расчетное положение и скорость участвуют в операциях ПИД и могут использоваться для управления горизонтальным положением. Обратитесь к файлу Position_pid.c, чтобы узнать, как обрабатываются ПИД-регулятор положения и кольца скорости.

Наконец, посредством описанного выше процесса можно обеспечить управление удержанием горизонтального положения.
